require "stringbuilder"
require "os"
require "arg"
require "io"

local AnsiColor = require 'ansicolor-nelua.ansicolor'

local Parser = require ".libs.parser"
local Cgen = require ".libs.cgen"
local lang_info = require ".generic.lang_info"

-- BUILD SECTION --

local function build_run_c_code(c_code: string, file_path: string, file_name: string): integer
  file_name = file_name .. "_" .. lang_info.LANG_NAME

  file_name = file_path .. file_name

  local GEN_C_PATH <const> = file_name .. ".c"
  local file, err = io.open(GEN_C_PATH, "w")
  assert(file:isopen(), err)
  file:write(c_code)
  file:close()

  local build_cmd = "tcc " .. GEN_C_PATH .. " -o " .. file_name .. " -Wextra -Wall && " .. file_name
  local _, _, code = os.execute(build_cmd)
  defer
    os.remove(GEN_C_PATH)
    os.remove(file_name)
  end
  return code
end

-- RUN SECTION --

local path = arg[1]
if path == "" then
  io.stderr:write(AnsiColor.new("error:"):Red():Bright():tostring(), " No path provided\n")
  os.exit(1)
end

local content: string
if path == "-" then
  content = io.read("a")
  path = "stdin"
else
  local file <close>, err = io.open(path, "r")
  if not file:isopen() then
    io.stderr:write(AnsiColor.new("error:"):Red():Bright():tostring(), (" Failed to open file '%s': %s\n"):format(path, err))
    os.exit(1)
  end
  content = file:read("a")
end

local new_parser_res = Parser.new(path, content)
if new_parser_res:is_err() then
  io.stderr:write(new_parser_res:get_err():tostring())
  os.exit(1)
end
local parser = new_parser_res:get_ok()

local parse_res = parser:parse()
if parse_res:is_err() then
  io.stderr:write(parse_res:get_err():tostring())
  os.exit(1)
end

local ast = parse_res:get_ok()

local file_path: string, file_name: string

if path:match("/") then
  local file_name_match, file_name_seq = path:match("(.*/)(.-)%." .. lang_info.LANG_NAME .. "$")
  if not file_name_match then
    io.stderr:write(AnsiColor.new("error:"):Red():Bright():tostring(), (" File path '%s' does not contain the language extenstion\n"):format(path))
    os.exit(1)
  end
  file_path = file_name_seq[1]
  file_name = file_name_seq[2]
else
  local file_name_match, file_name_seq = path:match("(.-)%." .. lang_info.LANG_NAME .. "$")
  if not file_name_match then
    io.stderr:write(AnsiColor.new("error:"):Red():Bright():tostring(), (" File path '%s' does not contain the language extenstion\n"):format(path))
    os.exit(1)
  end
  file_path = "./"
  file_name = file_name_seq[1]
end

local cgen = Cgen.new(ast, file_name)

local c_code = cgen:final()

-- print(c_code)

return build_run_c_code(c_code, file_path, file_name)
