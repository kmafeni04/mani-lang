require "map-nelua.map"

local tokenizer = require ".tokenizer"
local Token = tokenizer.Token
local TokenKind = tokenizer.TokenKind
local TokenKind_tostring = tokenizer.TokenKind_tostring

local Parser = require ".parser"
local Node = Parser.Node
local NodeKind = Parser.NodeKind
local NodeKind_tostring = Parser.NodeKind_tostring
local builtin_types = Parser.builtin_types

local ErrLoc = require ".errloc"
local ErrLocKind = ErrLoc.ErrLocKind

local varaint = require "variant-nelua.variant"
local Option = varaint.Option

local lang_info = require "..generic.lang_info"

local Cgen = @record{
  scope: *Node,
  parser: *Parser,
  sb_head: *stringbuilder,
  prefix: string
}

function Cgen.new(scope: *Node, parser: *Parser, prefix: string): Cgen
  assert(scope and scope:is_scope())
  assert(parser)

  local cgen: Cgen = {
    scope = scope,
    parser = parser,
    sb_head = new(stringbuilder),
    prefix = prefix
  }

  return cgen
end

local Cgen.gen_scope: function(self: *Cgen): string
local Cgen.gen_expr: function(self: *Cgen, node: *Node): string

local print_funcs: sequence(string)
local anon_func_count = 0
local anon_rec_count = 0
local string_eq_func_used: boolean
local string_eq_func = ([[
bool %s_eq_string(%s_string a, %s_string b) {
  return a.len == b.len && (a.data == b.data || a.len == 0 || memcmp(a.data, b.data, a.len) == 0);
}
]]):format(lang_info.LANG_NAME, lang_info.LANG_NAME, lang_info.LANG_NAME)

function Cgen.string(s: string): string
  return ('{ "%s", %d }'):format(s, #s)
end

function Cgen:gen_bin_expr(node: *Node): string
  assert(node and node.kind == NodeKind.BIN_EXPR)
  local sb: stringbuilder

  local lhs_value: string = self:gen_expr(node.lhs)
  local rhs_value: string = self:gen_expr(node.rhs)

  assert(builtin_types["string"])
  if node.op.kind == TokenKind.EQUATES then
    if self.parser:check_node_type(node.lhs.type, node.rhs):is_some() then
      sb:write("false")
    elseif node.lhs.type == builtin_types["string"] and node.rhs.type == builtin_types["string"] then
      if not string_eq_func_used then
        self.sb_head:write(string_eq_func)
        string_eq_func_used = true
      end
      sb:write("mani_eq_string(", lhs_value, ", ", rhs_value, ")")
    else
      sb:write(lhs_value, " ", node.op.val, " ", rhs_value)
    end
  else
    sb:write(lhs_value, " ", node.op.val, " ", rhs_value)
  end
  return sb:promote()
end

function Cgen:gen_type(t: *Node): string
  assert(t and ((t.kind == NodeKind.TYPE) or (t.kind == NodeKind.ID and t.type.kind == NodeKind.TYPE)) )

  local str: string = _switch!(true, {
    [t.is_string] = lang_info.LANG_NAME .. "_string",
    [t.is_niltype] = lang_info.LANG_NAME .. "_niltype",
    [t.is_i64] = "int64_t",
    [t.is_boolean] = "bool",
    [t.is_u64] = "uint64_t",
    [t.is_u8] = "uint8_t",
    [t.is_array] = self:gen_type(t.val),
    [t.kind == NodeKind.ID] = self.prefix .. "_" .. t.name,
    [t.is_rec] = (do
      if t.is_anonymous then
        in self.prefix .. "_anon_rec_" .. anon_rec_count
      end
      in self.prefix .. "_" .. t.name
    end),
    _default = (do
      error(("Unhandled type '%s'"):format(t.name))
      in ""
    end),
  })
  return str
end

function Cgen:gen_anon_proc_def(node: *Node)
  assert(node.kind == NodeKind.PROC_DEF)
  assert(node.type.is_anonymous)

  anon_func_count = anon_func_count + 1
  local sb: stringbuilder

  local ret_t = self:gen_type(node.ret_t)

  sb:write("typedef ", ret_t, " (*anon_func_", anon_func_count, "_type)(")
  if #node.params > 0 then
    for i, param in ipairs(node.params) do
      sb:write(self:gen_type(param.type), " ", param.name)
      if i < #node.params then
        sb:write(", ")
      end
    end
  else
    sb:write("void")
  end
  sb:write(");\n\n")
  sb:write(ret_t, " anon_func_", anon_func_count, "(")
  for i, param in ipairs(node.params) do
    sb:write(self:gen_type(param.type), " ", param.name)
    if i < #node.params then
      sb:write(", ")
    end
  end
  sb:write(") {\n") -- Cgen.gen_scope runs before the write of "{\n" so it was seperated
  sb:write(self:gen_scope(), "};\n\n")

  self.sb_head:write(sb:promote())

end

function Cgen:gen_proc_def(node: *Node)
  assert(node.kind == NodeKind.PROC_DEF)
  assert(node.type.is_proc)

  if not node.used then
    return
  end

  local sb: stringbuilder

  local ret_t = self:gen_type(node.ret_t)

  local name = self.prefix .. "_" .. node.name

  local proc_gen = Cgen.new(node, self.parser, self.prefix)
  proc_gen.sb_head = self.sb_head

  sb:write("typedef ", ret_t, " (*", name, "_type)(")
  for i, param in ipairs(node.params) do
    sb:write(proc_gen:gen_type(param.type), " ", self.prefix, "_", param.name)
    if i < #node.params then
      sb:write(", ")
    end
  end
  sb:write(");\n\n")
  sb:write(ret_t, " ", name, "(")
  for i, param in ipairs(node.params) do
    sb:write(proc_gen:gen_type(param.type), " ", self.prefix, "_", param.name)
    if i < #node.params then
      sb:write(", ")
    end
  end
  sb:write(") {\n") -- Cgen.gen_scope runs before the write of "{\n" so it was seperated
  sb:write(proc_gen:gen_scope(), "};\n\n")

  self.sb_head:write(sb:promote())

end

local function print_arg_snippet(print_arg: string, t: *Node): string
  assert(t and (t.kind == NodeKind.TYPE) or (t.kind == NodeKind.ID and t.type.kind == NodeKind.TYPE) )

  local sb: stringbuilder

  local _: niltype _switch!(true, {
    [t.is_string] = (do
      sb:write(
        "if(",
        print_arg,
        ".len > 0) {\n",
        "fwrite(",
        print_arg,
        ".data, 1, ",
        print_arg,
        '.len, stdout);\n} else { fputs("", stdout); }\n'
      )
      in nil
    end),
    [t.is_integral] = (do
      sb:write('fprintf(stdout, "%ld", ', print_arg, ");\n")
      in nil
    end),
    [t.is_niltype] = (do
      sb:write('fputs("nil", stdout);\n')
      in nil
    end),
    [t.is_float] = (do
      sb:write('fprintf(stdout, "%g", ', print_arg, ");\n")
      in nil
    end),
    _default = (do
      error(("TODO: Unhandled arg type '%s'"):format(t.name))
      in nil
    end),
    [t.is_array] = (do
      sb:write('fputs("[", stdout);\n')
      for i = 1, t.len do
        if t.val.is_string then
          sb:write('fputs("\\"", stdout);\n')
        end
        sb:write(print_arg_snippet(print_arg .. "[" .. i-1 .. "]", t.val))
        if t.val.is_string then
          sb:write('fputs("\\"", stdout);\n')
        end
        if i < t.len then
          sb:write('fputs(",", stdout);\n')
        end
      end
      sb:write('fputs("]", stdout);\n')
      in nil
    end),
    [t.is_boolean] = (do
      sb:write('fputs(', print_arg, ' ? "true" : "false", stdout);\n')
      in nil
    end),
    [t.is_rec] = (do
      sb:write('fputs("', t.name, "{ ")
      for i = 1, #t.fields do
        local field = t.fields[i]
        sb:write(field.name, ": ", field.type.name)
        if i < #t.fields then
          sb:write(", ")
        end
      end
      sb:write(' }", stdout);\n')
      in nil
    end),
    _default = (do
      error(("TODO: Unhandled arg type '%s'"):format(t:tostring()))
      in nil
    end),
    [t.type.is_rec] = (do
      -- sb:write()
      sb:write('fputs("{ ", stdout);\n')
      for i = 1, #t.type.fields do
        local field = t.type.fields[i]
        sb:write('fputs("', field.name, ' = ", stdout);\n')
        sb:write(print_arg_snippet(print_arg .. "." .. field.name, field.type))
        if i < #t.type.fields then
          sb:write('fputs(", ", stdout);\n')
        end
      end
      sb:write('fputs(" }", stdout);\n')
      in nil
    end),
  })

  return sb:promote()
end

function Cgen:gen_print(node: *Node): string
  assert(node and node.kind == NodeKind.PROC_CALL)

  local sb: stringbuilder
  sb:write("void ", lang_info.LANG_NAME, "_print_", #print_funcs + 1, " (")

  local print_args_sb: stringbuilder

  if # node.args > 0 then
    for i, arg in ipairs(node.args) do
      if arg.is_type_id then
        assert(builtin_types:has("niltype"))
        sb:write(lang_info.LANG_NAME, "_", builtin_types["niltype"].name , " a", i)
      else
        sb:write(self:gen_type(arg.type), " a", i)
        if arg.type.is_array then
          sb:write(" [", arg.type.len, "] ")
        end
      end
      if i < #node.args then
        sb:write(", ")
      end
      print_args_sb:write(arg.type, ", ")
    end
  end
  local print_funcs_i = 0
  for i, v in ipairs(print_funcs) do
    if v == print_args_sb:view() then
      print_funcs_i = i
      break
    end
  end

  if print_funcs_i == 0 then
    print_funcs:push(print_args_sb:promote())
    sb:write(") {\n")

    for i, arg in ipairs(node.args) do
      sb:write(print_arg_snippet("a" .. i, arg.type))
      sb:write("fflush(stdout);\n")
      if i < #node.args then
        sb:write('fputs("\\t", stdout);\n')
      end
    end
    sb:write('fputs("\\n", stdout);\n')
    sb:write("};\n\n")
    self.sb_head:write(sb:promote())
  end
  local print_sb: stringbuilder
  print_sb:write(lang_info.LANG_NAME, "_print_", print_funcs_i > 0 and print_funcs_i or #print_funcs, "(")
  for i, arg in ipairs(node.args) do
    if arg.is_type_id then
      print_sb:write(lang_info.LANG_NAME:upper(), "_NIL")
    else
      print_sb:write(self:gen_expr(arg))
    end
    if i < #node.args then
      print_sb:write(", ")
    end
  end

  print_sb:write(")")
  return print_sb:promote()
end

function Cgen:gen_proc_call(node: *Node): string
  assert(node and node.kind == NodeKind.PROC_CALL)

  local sb: stringbuilder
  sb:write(self.prefix, "_", node.name, "(")
  for i, arg in ipairs(node.args) do
    sb:write(self:gen_expr(arg))
    if i < #node.args then
      sb:write(", ")
    end
  end
  sb:write(")")
  return sb:promote()
end

function Cgen:gen_array(node: *Node): string
  local sb: stringbuilder
  sb:write("{")
  for i, v in ipairs(node.fields) do
    sb:write(self:gen_expr(v))
    if i < #node.fields then
      sb:write(", ")
    end
  end
  sb:write("}")
  return sb:promote()
end

function Cgen:gen_rec_def(node: *Node)
  assert(node.kind == NodeKind.TYPE)

  anon_rec_count = anon_rec_count + 1
  local sb: stringbuilder

  local name = self.prefix .. "_" .. (node.is_anonymous and "anon_rec_" .. anon_rec_count or node.name)

  sb:write("typedef struct {\n")
  for _, field in ipairs(node.fields) do
    sb:write(self:gen_type(field.type), " ", field.name)
    if field.type.is_array then
      sb:write("[", field.type.len, "]")
    end
    sb:write(";\n")
  end
  sb:write("} ", name, ";\n\n")

  self.sb_head:write(sb:promote())
end

local array_bound_check_count: integer

function Cgen:gen_array_bound_check(node: *Node): string
  assert(node)

  local errloc_str = ErrLoc.new(
    ErrLocKind.RUNTIME,
    self.parser.loc,
    "index is out of bounds",
    node.val.s_pos,
    node.val.e_pos
  ):tostring():gsub("\27", "\\033"):gsub("\n", "\\n"):gsub('"', '\\"')

  -- print(errloc_str)
  local array_bound_check_name = ("%s_array_bound_check_%d"):format(lang_info.LANG_NAME, array_bound_check_count + 1)

  self.sb_head:write(([[
  int64_t %s(int64_t index, uint64_t len) {
    if((uint64_t)index >= len || index < 0 ) {
      fputs("%s", stderr);
      abort();
    }
    return index;
  }
  ]]):format(array_bound_check_name, errloc_str))
  array_bound_check_count = array_bound_check_count + 1

  local len = node.parent.type.is_type_id and node.parent.type.type.len or node.parent.type.len

  local sb: stringbuilder
  sb:write("[", array_bound_check_name, "(", self:gen_expr(node.val), ", ", len, ")]")
  return sb:promote()
end

Cgen.gen_expr = function(self: *Cgen, node: *Node): string
  assert(node)

  local str: string = _switch!(node.kind, {
    [NodeKind.PROC_CALL] = (do
      local proc_call_sb: stringbuilder
      local id: Option(*Node) = Parser.find_decl_up_scope(self.scope, node.name, node.s_pos.index)
      if not (id:is_some() and id:get_some().name == "print") and node.name == "print" then
        proc_call_sb:write(self:gen_print(node))
      else
        proc_call_sb:write(self:gen_proc_call(node))
      end
      in proc_call_sb:promote()
    end),
    [NodeKind.LITERAL] = (do
      if node.type.is_string then
        in "(".. lang_info.LANG_NAME .. "_string)" .. Cgen.string(node.lit_val)
      elseif node.type.is_integral then
        in node.lit_val
      elseif node.type.is_boolean then
        in node.lit_val
      elseif node.type.is_niltype then
        in lang_info.LANG_NAME:upper() .. "_NIL"
      else
        error(("Unhandled literal node type '%s'"):format(node.type.name))
      end
      in ""
    end),
    [NodeKind.BIN_EXPR] = self:gen_bin_expr(node),
    [NodeKind.PROC_DEF] = (do
      if node.type.is_anonymous then
        self:gen_anon_proc_def(node)
      end
      in ""
    end),
    [NodeKind.ARRAY] = self:gen_array(node),
    [NodeKind.ID] = (do
      if node.is_type_id and not node.type.is_anonymous then
        in ""
      end
      local id_sb: stringbuilder
      id_sb:write(self.prefix, "_", node.name)
      in id_sb:promote()
    end),
    [NodeKind.INDEX] = (do
      -- TODO: Bounds checking
      local index_sb: stringbuilder
      index_sb:write(self:gen_expr(node.parent), self:gen_array_bound_check(node))
      in index_sb:promote()
    end),
    [NodeKind.TYPE] = (do
      -- if node.is_rec then
      --   if node.is_anonymous then
      --     self:gen_rec_def(node)
      --   end
      -- else
      --   error(("Unknown type '%s'"):format(node.name))
      -- end
      in ""
    end),
    [NodeKind.INIT_LIST] = (do
      local init_list_sb: stringbuilder
      local name: string = self.prefix .. "_" .. (node.type.is_anonymous and "anon_rec_" .. anon_rec_count + 1 or node.type.name)
      init_list_sb:write("(", name , ")", "{")
      for i = 1, #node.fields do
        local field = node.fields[i]
        init_list_sb:write(" .", field.name, " = ", self:gen_expr(field.val), ", ")
      end
      init_list_sb:write("}")
      in init_list_sb:promote()
    end),
    [NodeKind.FIELD] = (do
      local field_sb: stringbuilder
      field_sb:write(self:gen_expr(node.parent), ".", node.name)
      in field_sb:promote()
    end),
    _default = (do
      error(("Unexpected expr node: '%s'"):format(node:tostring()))
      in ""
    end),
  })

  return str
end

function Cgen:gen_while_loop(node: *Node): string
  assert(node and node.kind == NodeKind.WHILE_LOOP)

  local while_loop_gen = Cgen.new(node, self.parser, self.prefix)
  while_loop_gen.sb_head = self.sb_head

  local cond_val: string = while_loop_gen:gen_expr(node.cond)

  local sb: stringbuilder
  sb:write("while (", cond_val, ") {\n", while_loop_gen:gen_scope(), "\n}")
  return sb:promote()
end

function Cgen:gen_if_stmt(node: *Node): string
  assert(node and node.kind == NodeKind.IF_STMT)

  local if_stmt_gen = Cgen.new(node, self.parser, self.prefix)
  if_stmt_gen.sb_head = self.sb_head

  local cond_val: string = if_stmt_gen:gen_expr(node.cond)

  local sb: stringbuilder
  sb:write("if (", cond_val, ") {\n", if_stmt_gen:gen_scope(), "\n}")
  return sb:promote()
end

function Cgen:gen_elif_stmt(node: *Node): string
  assert(node and node.kind == NodeKind.ELIF_STMT)

  local elif_stmt_gen = Cgen.new(node, self.parser, self.prefix)
  elif_stmt_gen.sb_head = self.sb_head

  local cond_val: string = elif_stmt_gen:gen_expr(node.cond)

  local sb: stringbuilder
  sb:write("else if (", cond_val, ") {\n", elif_stmt_gen:gen_scope(), "\n}")
  return sb:promote()
end

function Cgen:gen_else_stmt(node: *Node): string
  assert(node and node.kind == NodeKind.ELSE_STMT)

  local else_stmt_gen = Cgen.new(node, self.parser, self.prefix)
  else_stmt_gen.sb_head = self.sb_head

  local sb: stringbuilder
  sb:write("else {\n", else_stmt_gen:gen_scope(), "\n}")
  return sb:promote()
end

function Cgen:gen_id_decl(node: *Node): string
  assert(node and node.kind == NodeKind.ID_DECL)

  if not node.used then
    return ""
  end

  local sb: stringbuilder

  local final_value: string
  if node.val then
    final_value = self:gen_expr(node.val)
  else
    final_value = "{0}"
  end
  local name = self.prefix .. "_" .. node.name
  local _: niltype = _switch!(true, {
    [node.type.is_niltype] = (do
      sb:write(self:gen_type(node.type), " ", name, " = ", lang_info.LANG_NAME:upper(), "_NIL;\n")
      in nil
    end),
    [node.type.is_string] = (do
      sb:write(self:gen_type(node.type), " ", name, " = ", final_value, ";\n")
      in nil
    end),
    [node.type.is_i64] = (do
      sb:write(self:gen_type(node.type), " ", name, " = ", final_value, ";\n")
      in nil
    end),
    [node.type.is_boolean] = (do
      sb:write(self:gen_type(node.type), " ", name, " = ", final_value, ";\n")
      in nil
    end),
    [node.type.is_proc] = (do
      if node.type.is_anonymous then
        sb:write("anon_func_", anon_func_count, "_type ", name, " = anon_func_", anon_func_count, ";\n")
      end
      in nil
    end),
    [node.type.is_array] = (do
      sb:write(self:gen_type(node.type) , " ", name, "[", node.type.len, "] = ", final_value, ";\n")
      in nil
    end),
    [node.type.is_type] = (do
      if node.val and node.val.is_anonymous then
        self:gen_rec_def(node.type)
        self.sb_head:write("typedef ", self.prefix, "_anon_rec_", anon_rec_count, " ", self.prefix, "_", node.name, ";\n")
      elseif node.type.is_anonymous then
        self:gen_rec_def(node.type)
        sb:write(self.prefix, "_anon_rec_", anon_rec_count, " ", name, " = ", final_value , ";\n")
        -- error()
      else
        self.sb_head:write("typedef ", self.prefix, "_", node.type.name, " ", self.prefix, "_", node.name, ";\n")
      end
      in nil
    end),
    [node.type.is_type_id] = (do
      if node.val and node.val.is_type_id then
        self.sb_head:write("typedef ", self.prefix, "_", node.type.name, " ", self.prefix, "_", node.name, ";\n")
      else
        sb:write(self.prefix, "_", node.type.name, " ", name, " = ", final_value , ";\n")
      end
      in nil
    end),
    _default = (do
      -- pr
      error(("Unhandled node type '%s'"):format(node.type:tostring()))
      in nil
    end),
  })
  sb:write("\n")
  return sb:promote()
end

function Cgen:gen_for_loop(node: *Node): string
  assert(node and node.kind == NodeKind.FOR_LOOP)

  local for_loop_gen = Cgen.new(node, self.parser, self.prefix)
  for_loop_gen.sb_head = self.sb_head

  local id_val: string = for_loop_gen:gen_id_decl(node.id)
  id_val = id_val:sub(0, #id_val - 2)

  local cond_val: string = self.prefix .. "_" .. node.id.name .. " <= " .. for_loop_gen:gen_expr(node.cond)

  local step_val: string
  if node.step then
    step_val = self.prefix .. "_" .. node.id.name .. " += " .. for_loop_gen:gen_expr(node.step)
  else
    step_val = self.prefix .. "_" .. node.id.name .. "++"
  end

  local sb: stringbuilder
  sb:write("for (", id_val, " " , cond_val, "; ", step_val, ") {\n", for_loop_gen:gen_scope(), "\n}")
  return sb:promote()
end

Cgen.gen_scope = function(self: *Cgen): string
  local sb: stringbuilder
  for i, child in ipairs(self.scope.children) do
    local child_str: string = _switch!(child.kind, {
      [NodeKind.COMMENT] = "",
      [NodeKind.PROC_CALL] = self:gen_expr(child) .. ";\n",
      [NodeKind.PROC_DEF] = (do
        self:gen_proc_def(child)
        in ""
      end),
      [NodeKind.FOR_LOOP] = self:gen_for_loop(child),
      [NodeKind.WHILE_LOOP] = self:gen_while_loop(child),
      [NodeKind.IF_STMT] = self:gen_if_stmt(child),
      [NodeKind.ELIF_STMT] = self:gen_elif_stmt(child),
      [NodeKind.ELSE_STMT] = self:gen_else_stmt(child),
      [NodeKind.BREAK] = "break;\n",
      [NodeKind.ID_DECL] = (do
        local id_decl: string = self:gen_id_decl(child)
        -- if self.scope.kind == NodeKind.AST and child.val and child.val.kind ~= NodeKind.PROC_CALL then
        --   self.sb_head:write(id_decl)
        --   in ""
        -- end
        in id_decl
      end),
      [NodeKind.RETURN] = (do
        local ret_sb: stringbuilder
        ret_sb:write("return ")
        if child.val then
          ret_sb:write(self:gen_expr(child.val))
        end
        ret_sb:write(";\n")
        in ret_sb:promote()
      end),
      [NodeKind.ASSIGNMENT] = (do
        local assign_sb: stringbuilder
        assign_sb:write(self:gen_expr(child.id), " = ", self:gen_expr(child.val), ";\n")
        in assign_sb:promote()
      end),
      [NodeKind.TYPE] = (do
        if child.is_rec then
          self:gen_rec_def(child)
        else
          error()
        end
        in ""
      end),
      _default = (do
        error(("Unexpected child node kind: '%s'"):format(NodeKind_tostring(child.kind)))
        in ""
      end),
    })

    sb:write(child_str)
  end
  return sb:promote()
end

function Cgen:final(): string
  local sb_main: stringbuilder

  local scope_str = self:gen_scope()
  sb_main:write(
    ([[
/* Disable some warnings that the generated code can trigger. */
#if defined(__clang__) && __clang_major__ >= 3
  #pragma clang diagnostic ignored "-Wtype-limits"
  #pragma clang diagnostic ignored "-Wwrite-strings"
  #pragma clang diagnostic ignored "-Wunused"
  #pragma clang diagnostic ignored "-Wunused-parameter"
  #pragma clang diagnostic ignored "-Wmissing-field-initializers"
  #pragma clang diagnostic ignored "-Wparentheses-equality"
  #pragma clang diagnostic ignored "-Wtautological-compare"
  #pragma clang diagnostic ignored "-Wmissing-braces"
  #ifndef __cplusplus
    #pragma clang diagnostic ignored "-Wincompatible-pointer-types"
    #pragma clang diagnostic error   "-Wimplicit-function-declaration"
    #pragma clang diagnostic error   "-Wimplicit-int"
  #else
    #pragma clang diagnostic ignored "-Wnarrowing"
    #pragma clang diagnostic ignored "-Wc99-designator"
  #endif
#elif defined(__GNUC__) && __GNUC__ >= 5
  #pragma GCC diagnostic ignored "-Wtype-limits"
  #pragma GCC diagnostic ignored "-Wwrite-strings"
  #pragma GCC diagnostic ignored "-Wunused-parameter"
  #pragma GCC diagnostic ignored "-Wunused-value"
  #pragma GCC diagnostic ignored "-Wunused-variable"
  #pragma GCC diagnostic ignored "-Wunused-function"
  #pragma GCC diagnostic ignored "-Wunused-but-set-variable"
  #pragma GCC diagnostic ignored "-Wmissing-field-initializers"
  #ifndef __cplusplus
    #pragma GCC diagnostic ignored "-Wmissing-braces"
    #pragma GCC diagnostic ignored "-Wincompatible-pointer-types"
    #pragma GCC diagnostic ignored "-Wdiscarded-qualifiers"
    #pragma GCC diagnostic error   "-Wimplicit-function-declaration"
    #pragma GCC diagnostic error   "-Wimplicit-int"
  #else
    #pragma GCC diagnostic ignored "-Wnarrowing"
  #endif
#endif
#if defined(_WIN32) && !defined(_CRT_SECURE_NO_WARNINGS)
  #define _CRT_SECURE_NO_WARNINGS
#endif

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <stdint.h>
#include <string.h>


typedef struct {
  char* data;
  uint64_t len;
} %s_string;

typedef struct {} %s_niltype;
#define %s_NIL (%s_niltype){}

]]):format(lang_info.LANG_NAME, lang_info.LANG_NAME, lang_info.LANG_NAME:upper(), lang_info.LANG_NAME),
    self.sb_head:promote(),
    "\nint main(int argc, char** argv) {\n",
    scope_str,
    "\n(void)(argc);\n(void)(argv);\nreturn 0;\n}"
  )

  return sb_main:promote()
end

return Cgen
