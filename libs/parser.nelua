-- TODO: remove 'for _, param in ipairs(node.params) do' from cgen and put in parse_proc_def

require "map-nelua.map"
require "switch-nelua.switch"

local varaint = require "variant-nelua.variant"
local Result = varaint.Result
local Option = varaint.Option

local Pos = require "..generic.pos"
local Loc = require "..generic.loc"
local lang_info = require "..generic.lang_info"

local pos_to_line_col = require ".pos_to_line_col"

local tokenizer = require ".tokenizer"
local Token = tokenizer.Token
local TokenKind = tokenizer.TokenKind
local TokenKind_tostring = tokenizer.TokenKind_tostring

local ErrLoc = require ".errloc"
local ErrLocKind = ErrLoc.ErrLocKind

local Parser = @record{
  loc: Loc,
  index: integer,
  tokens: sequence(Token)
}

local function error_unexpected_token(parser: *Parser, token: Token): ErrLoc
  assert(parser)
  range_check!(token.kind, TokenKind)

  return ErrLoc.new(
    ErrLocKind.SYNTAX,
    parser.loc,
    ("Unexpected Token '%s'"):format(token.val),
    token.s_pos,
    token.e_pos
  )
end

local function error_redeclaration(parser: *Parser, token: *Token): ErrLoc
  assert(parser)
  range_check!(token.kind, TokenKind)

  return ErrLoc.new(
    ErrLocKind.SEMANTIC,
    parser.loc,
    ("Redeclaration of identifier '%s'"):format(token.val),
    token.s_pos,
    token.e_pos
  )
end

local function error_undefined_identifier(parser: *Parser, token: *Token): ErrLoc
  assert(parser)
  range_check!(token.kind, TokenKind)

  return ErrLoc.new(
    ErrLocKind.SEMANTIC,
    parser.loc,
    ("Undefinded identifier '%s'"):format(token.val),
    token.s_pos,
    token.e_pos
  )
end

local NewParserResult = @Result(Parser, ErrLoc)
function Parser.new(path: string, content: string): NewParserResult
  local tokenize_res = tokenizer.tokenize(path, content)
  if tokenize_res:is_err() then
    return NewParserResult.err(tokenize_res:get_err())
  end
  return NewParserResult.ok({
    loc = {
      path = path,
      content = content,
    },
    index = 1,
    tokens = tokenize_res:get_ok(),
  })
end

function Parser:peek()
  if self.index <= #self.tokens then
    return self.tokens[self.index]
  end

  local line, col = pos_to_line_col(#self.loc.content, self.loc.content)
  return Token{
    kind = TokenKind.EOF,
    val = "",
    s_pos = {
      index = #self.loc.content,
      line = line,
      col = col,
    },
    e_pos = {
      index = #self.loc.content,
      line = line,
      col = col,
    },
  }
end

function Parser:peek_next()
  if self.index + 1 <= #self.tokens then
    return self.tokens[self.index + 1]
  end

  local line, col = pos_to_line_col(#self.loc.content, self.loc.content)
  return Token{
    kind = TokenKind.EOF,
    val = "",
    s_pos = {
      index = #self.loc.content,
      line = line,
      col = col,
    },
    e_pos = {
      index = #self.loc.content,
      line = line,
      col = col,
    },
  }
end

function Parser:peek_prev()
  if self.index - 1 <= #self.tokens then
    return self.tokens[self.index - 1]
  end

  local line, col = pos_to_line_col(#self.loc.content, self.loc.content)
  return Token{
    kind = TokenKind.EOF,
    val = "",
    s_pos = {
      index = #self.loc.content,
      line = line,
      col = col,
    },
    e_pos = {
      index = #self.loc.content,
      line = line,
      col = col,
    },
  }
end

function Parser:advance()
  local token  = self:peek()
  self.index = self.index + 1
  return token
end

local ExpectResult = @Result(Token, ErrLoc)

function Parser:expect_one_of(token_kinds: sequence(TokenKind), msg: string): ExpectResult
  assert(#token_kinds > 0)

  local token = self:advance()

  for _, token_kind in ipairs(token_kinds) do
    range_check!(token_kind, TokenKind)
    if token_kind == token.kind then
      return ExpectResult.ok(token)
    end
  end

  local sb: stringbuilder
  if msg ~= "" then
    sb:write(msg)
  elseif #token_kinds == 1 then
    sb:write("Expected TokenKind '", TokenKind_tostring(token_kinds[1]), "' but got '", TokenKind_tostring(token.kind), "'")
  else
    sb:write("Expected one of TokenKinds '{ ")
    for _, token_kind in  ipairs(token_kinds) do
      range_check!(token_kind, TokenKind)
      sb:write(TokenKind_tostring(token_kind))
      sb:write(", ")
    end
    sb:rollback(2)
    sb:write(" }' but got '", TokenKind_tostring(token.kind), "'")
  end

  return ExpectResult.err(ErrLoc.new(ErrLocKind.SYNTAX, self.loc, sb:promote(), token.s_pos, token.e_pos))
end

function Parser:expect(token_kind: TokenKind, msg: string): ExpectResult
  return self:expect_one_of({ token_kind }, msg)
end

function Parser:is(token_kinds: sequence(TokenKind)): boolean

  for _, kind in ipairs(token_kinds) do
    if kind == self:peek().kind then
      return true
    end
  end

  return false
end

function Parser:advance_comma_unless(token_kind: TokenKind): ExpectResult
  range_check!(token_kind, TokenKind)

  local token = self:peek()
  if token.kind == TokenKind.COMMA then
    if self:peek_next().kind == token_kind or self:peek_next().kind == TokenKind.EOF then
      return ExpectResult.err(ErrLoc.new(ErrLocKind.SYNTAX, self.loc, "Trailing comma", token.s_pos, token.e_pos))
    end
    return ExpectResult.ok(self:advance())
  end

  if token.kind ~= token_kind and token.kind ~= TokenKind.EOF then
    return ExpectResult.err(ErrLoc.new(
      ErrLocKind.SYNTAX,
      self.loc,
      ("Expected Token value ',' but got '%s'"):format(token.val),
      token.s_pos,
      token.e_pos)
    )
  end

  return ExpectResult.ok(token)
end

function Parser:advance_comma_until(token_kind: TokenKind): ExpectResult
  range_check!(token_kind, TokenKind)

  local token = self:peek()
  if token.kind == TokenKind.COMMA then
    return ExpectResult.ok(self:advance())
  end

  if token.kind ~= token_kind and token.kind ~= TokenKind.EOF then
    return ExpectResult.err(ErrLoc.new(
      ErrLocKind.SYNTAX,
      self.loc,
      ("Expected Token value ',' but got '%s'"):format(token.val),
      token.s_pos,
      token.e_pos)
    )
  end

  return ExpectResult.ok(token)
end

local Node <forwarddecl> = @record{}

local NodeKind = @enum{
  _UNDEFINED = 0,
  ARRAY,
  ASSIGNMENT,
  AST,
  BIN_EXPR,
  BREAK,
  COMMENT,
  ELIF_STMT,
  ELSE_STMT,
  FIELD,
  FOR_LOOP,
  ID,
  ID_DECL,
  IF_STMT,
  INDEX,
  INIT_FIELD,
  INIT_LIST,
  LITERAL,
  PROC_CALL,
  PROC_DEF,
  RETURN,
  TYPE,
  WHILE_LOOP,
  _COUNT
}

local function NodeKind_tostring(kind: NodeKind): string
  range_check!(kind, NodeKind)
  ## for _, field in ipairs(NodeKind.value.fields) do
    if #[field.value]# == kind then
      return #[field.name]#
    end
  ## end
  error("UNREACHABLE")
  return ""
end

local Annotations = @record{
  constant: boolean
}

Node = @record{
  kind: NodeKind,

  s_pos: Pos,
  e_pos: Pos,

  name: string,
  type: *Node,

  children: sequence(*Node),
  scope: *Node,

  annotations: Annotations,

  -- Scope
  content: string,

  -- ProcDef
  params: sequence(*Node),
  ret_t: *Node,

  -- ProcCall
  args: sequence(*Node),

  id: *Node,

  parent: *Node,

  -- BinOp
  lhs: *Node,
  op: Token,
  rhs: *Node,

  -- WhileLoop|ForLoop|IfStmt
  cond: *Node,
  step: *Node,

  -- Literal
  lit_val: string,

  -- IdDecl
  used: boolean,

  -- Array
  len: uinteger,

  -- Record
  fields: sequence(*Node),
  is_builtin: boolean,
  is_boolean: boolean,
  is_scalar: boolean,
  is_integral: boolean,
  is_float: boolean,
  is_string: boolean,
  is_array: boolean,
  is_pointer: boolean,
  is_proc: boolean,
  is_niltype: boolean,
  is_any: boolean,
  -- is_vararg: boolean,
  is_type_type: boolean,

  is_type_id: boolean,

  is_rec: boolean,
  is_type: boolean,

  is_i64: boolean,
  is_u64: boolean,
  is_u8: boolean,
  is_f64: boolean,

  is_anonymous: boolean,
  is_unbounded: boolean,

  val: *Node,
}

function Node:tostring(indent: integer, inline: boolean): string
  range_check!(self.kind, NodeKind)

  local indent_str = string.rep("  ", indent)
  local sb: stringbuilder
  if not inline then
    sb:write(indent_str)
  end
  sb:write(NodeKind_tostring(self.kind))
  switch self.kind do
    case NodeKind.AST then
      sb:write("\n")
    case NodeKind.ID_DECL then
      sb:write(" -> ", self.name, ": ", self.type:tostring(indent, true))
      if self.val then
        sb:write(" = ", self.val:tostring(indent, true))
      end
      if not inline then
        sb:write("\n")
      end
    case NodeKind.LITERAL then
      sb:write("(")
      if self.type.is_string then
        sb:write('"')
      end
      sb:write(self.lit_val)
      if self.type.is_string then
        sb:write('"')
      end
      sb:write(")")
    case NodeKind.TYPE then
      sb:write(" ")
      if self.is_rec then
        sb:write(self.name, "{\n")
        for i, field in ipairs(self.fields) do
          sb:write(field:tostring(indent + 1))
        end
        sb:write(indent_str, "}")
      else
        sb:write(self.name)
      end
      if not inline then
        sb:write("\n")
      end
    case NodeKind.ID then
      sb:write(" -> ", self.name, ": ", self.type:tostring(indent + 1, true))
    case NodeKind.PROC_CALL then
      sb:write(" ", self.name, "(\n")
      for _, arg in ipairs(self.args) do
        sb:write(arg:tostring(indent + 1))
      end
      sb:write("\n", indent_str ,")\n")
    case NodeKind.FIELD then
      sb:write(" -> ", self.name, ": ", self.type:tostring(indent + 1, true))
    case NodeKind.WHILE_LOOP, NodeKind.IF_STMT, NodeKind.ELIF_STMT then
      sb:write(" -> ", self.cond:tostring(indent + 1, true), "\n")
    case NodeKind.ELSE_STMT then
      sb:write("\n")
    case NodeKind.BREAK then
      sb:write("\n")
    case NodeKind.BIN_EXPR then
      sb:write(
        "(",
        self.lhs:tostring(indent + 1, true),
        " OP(",
        self.op.val,
        ") ",
        self.rhs:tostring(indent + 1, true),
        ")"
      )
    case NodeKind.ASSIGNMENT then
      sb:write(
        " -> ",
        self.id:tostring(indent + 1, true),
        ": ", self.id.type:tostring(indent + 1, true),
        " = ", self.val:tostring(indent + 1, true),
        "\n"
      )
    case NodeKind.COMMENT then
      sb:write("\n")
    case NodeKind.FOR_LOOP then
      sb:write(" -> (", self.id:tostring(indent + 1, true), " ; " , self.cond:tostring(indent + 1, true))
      if self.step then
        sb:write(" ; ", self.step:tostring(indent + 1, true))
      end
      sb:write(")\n")
    case NodeKind.ARRAY then
      sb:write("[\n")
      for i, field in ipairs(self.fields) do
        sb:write(field:tostring(indent + 1), "\n")
      end
      sb:write(indent_str, "]")
    case NodeKind.INDEX then
      sb:write(" -> ", self.parent:tostring(indent + 1, true), " [", self.val:tostring(indent + 1, true) ,"]")
    case NodeKind.INIT_LIST then
      sb:write(" {\n")
      for i, field in ipairs(self.fields) do
        sb:write(field:tostring(indent + 1), "\n")
      end
      sb:write(indent_str, "}")
    case NodeKind.INIT_FIELD then
      sb:write(" -> ", self.name, " = ", self.val:tostring(indent + 1, true))
    case NodeKind.PROC_DEF then
      fallthrough
    case NodeKind.RETURN then
      fallthrough
    else
      error(("TODO: Node:tostring '%s'"):format(NodeKind_tostring(self.kind)))
  end
  if self.children then
    for _, child in ipairs(self.children) do
      sb:write(child:tostring(indent + 1))
    end
  end
  return sb:promote()
end

function Node:is_scope(): boolean
  switch self.kind do
    case
      NodeKind.AST,
      NodeKind.PROC_DEF,
      NodeKind.WHILE_LOOP,
      NodeKind.FOR_LOOP,
      NodeKind.IF_STMT,
      NodeKind.ELIF_STMT,
      NodeKind.ELSE_STMT
    then
      return true
  end
  return false
end

function Node:is_loop(): boolean
  switch self.kind do
    case
      NodeKind.WHILE_LOOP
    then
      return true
  end
  return false
end

local ParseResult = @Result(*Node, ErrLoc)

local Parser.parse_expr: function(self: *Parser, scope: *Node): ParseResult
local Parser.parse_scope: function(self: *Parser, scope: *Node, till: TokenKind): ParseResult
local Parser.check_node_type: function(self: *Parser, typ: *Node, node: *Node): Option(ErrLoc)
local Parser.parse_primary: function(self: *Parser, scope: *Node, current_node: *Node): ParseResult
local Parser.parse_record: function(self:*Parser, scope: *Node): ParseResult

local type_type: Node = {
  kind = NodeKind.TYPE,
  name = "type",
  is_builtin = true,
  is_type_type = true,
  is_type = true,
}
type_type.type = &type_type

local i64_type: Node = {
  kind = NodeKind.TYPE,
  name = "i64",
  is_builtin = true,
  is_scalar = true,
  is_integral = true,
  is_i64 = true,
  is_type = true,
  type = &type_type
}

local f64_type: Node = {
  kind = NodeKind.TYPE,
  name = "f64",
  is_builtin = true,
  is_scalar = true,
  is_float = true,
  is_f64 = true,
  is_type = true,
  type = &type_type
}

local u64_type: Node = {
  kind = NodeKind.TYPE,
  name = "u64",
  is_builtin = true,
  is_scalar = true,
  is_integral = true,
  is_u64 = true,
  is_type = true,
  type = &type_type
}

local u8_type: Node = {
  kind = NodeKind.TYPE,
  name = "u8",
  is_builtin = true,
  is_scalar = true,
  is_integral = true,
  is_u8 = true,
  is_type = true,
  type = &type_type
}

local string_data_type: Node = {
  kind = NodeKind.TYPE,
  name = "*[0]u8",
  val = &u8_type,
  len = 0,
  is_array = true,
  is_unbounded = true,
  is_type = true,
  type = &type_type
}

local string_data: Node = {
  kind = NodeKind.ID_DECL,
  name = "data",
  type = &string_data_type,
}

local string_len: Node = {
  kind = NodeKind.ID_DECL,
  name = "len",
  type = &u64_type,
}

local string_type: Node = {
  kind = NodeKind.TYPE,
  name = "string",
  is_builtin = true,
  is_string = true,
  is_rec = true,
  is_anonymous = true,
  fields = {
    &string_data,
    &string_len,
  },
  is_type = true
}
string_type.type = &string_type

local niltype_type: Node = {
  kind = NodeKind.TYPE,
  name = "niltype",
  is_builtin = true,
  is_niltype = true,
  is_type = true,
  type = &type_type
}

local boolean_type: Node = {
  kind = NodeKind.TYPE,
  name = "boolean",
  is_builtin = true,
  is_boolean = true,
  is_type = true,
  type = &type_type
}

local any_type: Node = {
  kind = NodeKind.TYPE,
  name = "any",
  is_builtin = true,
  is_any = true,
  is_type = true,
  type = &type_type
}

-- local vararg_type: Node = {
--   kind = NodeKind.TYPE,
--   name = "vararg",
--   is_builtin = true,
--   is_vararg = true,
--   is_type = true
-- }
-- vararg_type.type = &vararg_type

local Np = @*Node
local builtin_types = map!(string, Np, {
  [type_type.name] = &type_type,
  [i64_type.name] = &i64_type,
  [f64_type.name] = &f64_type,
  [u64_type.name] = &u64_type,
  [u8_type.name] = &u8_type,
  [string_type.name] = &string_type,
  [boolean_type.name] = &boolean_type,
  [niltype_type.name] = &niltype_type,
  [any_type.name] = &any_type,
  -- [vararg_type.name] = &vararg_type,
})

local function new_array_type(scope: *Node, len: integer, sub_type: *Node, s_pos: Pos, e_pos: Pos): *Node
  assert(scope and scope:is_scope())
  assert(sub_type)


  local array_type_name_sb: stringbuilder
  array_type_name_sb:write("[", len, "]", sub_type.name)

  local array_type = new(Node)

  $array_type = {
    kind = NodeKind.TYPE,

    s_pos = s_pos,
    e_pos = e_pos,
    scope = scope,

    name = array_type_name_sb:promote(),
    val = sub_type,
    len = len,
    is_array = true,
    is_type = true,
    type = &type_type
  }

  return array_type
end


local BinOpInfo = @record{
  op: TokenKind,
  type: *Node,
  possible_lht: sequence(*Node),
  possible_rht: sequence(*Node),
}

local bin_ops = map!(TokenKind, BinOpInfo, {
  [TokenKind.EQUATES] = {
    op = TokenKind.OPEN_ANGLE,
    type = builtin_types[boolean_type.name],
    possible_lht = { builtin_types[any_type.name] },
    possible_rht = { builtin_types[any_type.name] },
  },
  [TokenKind.OPEN_ANGLE] = {
    op = TokenKind.OPEN_ANGLE,
    type = builtin_types[boolean_type.name],
    possible_lht = { builtin_types[i64_type.name] },
    possible_rht = { builtin_types[i64_type.name] },
  },
  [TokenKind.CLOSE_ANGLE] = {
    op = TokenKind.CLOSE_ANGLE,
    type = builtin_types[boolean_type.name],
    possible_lht = { builtin_types[i64_type.name] },
    possible_rht = { builtin_types[i64_type.name] },
  },
  [TokenKind.PLUS] = {
    op = TokenKind.PLUS,
    type = builtin_types[i64_type.name],
    possible_lht = { builtin_types[i64_type.name] },
    possible_rht = { builtin_types[i64_type.name] },
  },
  [TokenKind.MINUS] = {
    op = TokenKind.MINUS,
    type = builtin_types[i64_type.name],
    possible_lht = { builtin_types[i64_type.name] },
    possible_rht = { builtin_types[i64_type.name] },
  },
  [TokenKind.STAR] = {
    op = TokenKind.STAR,
    type = builtin_types[i64_type.name],
    possible_lht = { builtin_types[i64_type.name] },
    possible_rht = { builtin_types[i64_type.name] },
  },
})

-- error("TODO: print_node")

local print_param: Node = {
  kind = NodeKind.ID_DECL,

  -- type = &vararg_type,
  name = "...",
}

local print_proc_type: Node
print_proc_type = {
  kind = NodeKind.TYPE,
  name = "proc_def",
  is_proc = true,
  is_type = true,
  params = { &print_param },
  ret_t = &niltype_type,
  type = &print_proc_type
}

-- NOTE: Hack to make proc available in scope
local print_proc_id_decl: Node = {
  kind = NodeKind.ID_DECL,

  is_builtin = true,

  name = "print",
  -- val = proc_def,
  type = &print_proc_type,
}

local builtin_procs = map!(string, Np, {
  ["print"] = &print_proc_id_decl,
})

function Parser:new_literal(scope: *Node, n_type: *Node): *Node
  assert(scope and scope:is_scope())

  local token = self:advance()

  local node = new(Node)
  $node = {
    kind = NodeKind.LITERAL,

    s_pos = token.s_pos,
    e_pos = token.e_pos,
    scope = scope,

    type = n_type,
    lit_val = token.val,
  }

  return node
end

function Parser:check_rec_fields(typ: *Node, init_list: *Node): Option(ErrLoc)
  assert(typ and typ.is_rec)
  assert(init_list and init_list.kind == NodeKind.INIT_LIST)

  local t_fields: hashmap(string, *Node)
  for _, field in ipairs(typ.fields) do
    t_fields[field.name] = field
  end

  for _, field in ipairs(init_list.fields) do
    local ok, t_field = t_fields:has_and_get(field.name)
    if not ok then
      return Option.Some(ErrLoc.new(
        ErrLocKind.SEMANTIC,
        self.loc,
        ("field '%s' is not present in record '%s'"):format(field.name, typ.name),
        field.s_pos,
        field.e_pos
      ))
    end

    local err_loc_opt = self:check_node_type(t_field.type, field.val)
    if err_loc_opt:is_some() then
      return Option.Some(err_loc_opt:get_some())
    end
  end

  return Option.None()
end

Parser.check_node_type = function(self: *Parser, t: *Node, node: *Node): Option(ErrLoc)
  assert(t and (t.kind == NodeKind.TYPE or (t.kind == NodeKind.ID and t.type.kind == NodeKind.TYPE)))
  assert(node)

  local typ = t.is_type and t or t.type

  if node.kind == NodeKind.INIT_LIST then
    if typ.is_rec then
      local err_loc_opt = self:check_rec_fields(typ, node)
      if err_loc_opt:is_some() then
        return err_loc_opt
      end
      node.type = t
      return Option.None()
    else
      return Option.Some(ErrLoc.new(
        ErrLocKind.SEMANTIC,
        self.loc,
        ("type '%s' cannot be initialized using an initializer list"):format(typ.name),
        node.s_pos,
        node.e_pos
      ))
    end
  end

  local node_type = node.is_type and node or node.type

  if typ.is_array and node_type.is_array then
    if typ.len >= node_type.len then
      local err_loc_opt = self:check_node_type(typ.val, node_type.val)
      if err_loc_opt:is_some() then
        return err_loc_opt
      end
      $node.type = $typ
      return Option.None()
    end
  elseif typ.is_type_type and node_type.is_rec then
    $typ = $node_type
    return Option.None()
  elseif typ.is_any then
    return Option.None()
  else
    if typ == node_type then
      return Option.None()
    end
  end

  return Option.Some(ErrLoc{
    kind = ErrLocKind.SEMANTIC,

    loc = self.loc,
    err = ("Type '%s' does not match type '%s'"):format(node_type.name, typ.name),

    s_pos = node.s_pos,
    e_pos = node.e_pos,
  })
end

function Parser:new_binary_expr(scope: *Node, lhs: *Node, op: Token, rhs: *Node): *Node
  assert(scope and scope:is_scope())
  assert(lhs)
  range_check!(op.kind, TokenKind)
  assert(rhs)

  assert(bin_ops:has(op.kind), op.val)
  local bin_op_info = bin_ops[op.kind]

  local ok: boolean
  local err_loc: ErrLoc
  for _, lht in ipairs(bin_op_info.possible_lht) do
    local err_loc_opt = self:check_node_type(lht, lhs)
    if err_loc_opt:is_none() then
      ok = true
    else
      err_loc = err_loc_opt:get_some()
    end
  end
  if not ok then
    error(err_loc:tostring())
  end

  ok = false
  for _, rht in ipairs(bin_op_info.possible_rht) do
    local err_loc_opt = self:check_node_type(rht, rhs)
    if err_loc_opt:is_none() then
      ok = true
    else
      err_loc = err_loc_opt:get_some()
    end
  end
  if not ok then
    error(err_loc:tostring())
  end

  local binary_expr = new(Node)
  $binary_expr = {
    kind = NodeKind.BIN_EXPR,

    s_pos = lhs.s_pos,
    e_pos = rhs.e_pos,
    scope = scope,

    lhs = lhs,
    op = op,
    rhs = rhs,
    type = bin_op_info.type
  }
  return binary_expr
end

function Parser:new_proc_call(scope: *Node, s_pos: Pos, e_pos: Pos, name: string, args: sequence(*Node), proc_type: *Node): *Node
  assert(scope and scope:is_scope())
  assert(proc_type)

  local proc_call = new(Node)
  $proc_call = {
    kind = NodeKind.PROC_CALL,

    s_pos = s_pos,
    e_pos = e_pos,
    scope = scope,

    name = name,
    args = args,
    type = proc_type,
  }

  return proc_call
end

function Parser.find_decl_up_scope(scope: *Node, name: string, s_index: integer): Option(*Node)
  assert(scope and scope:is_scope())

  for _, node in ipairs(scope.children) do
    if (
      node.kind == NodeKind.ID_DECL
      or node.kind == NodeKind.PROC_DEF
      or (node.kind == NodeKind.TYPE and not node.is_builtin)
    ) and node.name == name and node.s_pos.index <= s_index then
      node.used = true
      return Option.Some(node)
    end
  end

  if scope.scope then
    return Parser.find_decl_up_scope(scope.scope, name, s_index)
  end
  return Option.None()
end

function Parser:parse_id(scope: *Node): ParseResult
  local expect_res = self:expect(TokenKind.IDENTIFIER)
  if expect_res:is_err() then
    return ParseResult.err(expect_res:get_err())
  end
  local token = expect_res:get_ok()

  if builtin_procs:has(token.val) then
    return ParseResult.ok(builtin_procs[token.val])
  end

  local decl_opt: Option(*Node) = Parser.find_decl_up_scope(scope, token.val, token.s_pos.index)
  if decl_opt:is_none() then
    return ParseResult.err({
      loc = self.loc,
      err = ("Undeclared identifier '%s'"):format(token.val),
      kind = ErrLocKind.SEMANTIC,
      s_pos = token.s_pos,
      e_pos = token.e_pos,
    })
  end

  local decl_node = decl_opt:get_some()

  local id_type: *Node = decl_node.is_type and decl_node or decl_node.type

  local id: *Node = new(Node)
  $id = {
    kind = NodeKind.ID,
    s_pos = token.s_pos,
    e_pos = token.e_pos,

    scope = scope,

    name = token.val,
    type = id_type,
    is_type_id = (decl_node.is_type or (decl_node.val and decl_node.val.is_type_id) or decl_node.type.is_anonymous),
    annotations = decl_node.annotations
  }

  return ParseResult.ok(id)
end

function Parser:parse_print(scope: *Node, parent: *Node): ParseResult
  assert(scope and scope:is_scope())
  assert(parent)

  local expect_res = self:expect(TokenKind.OPEN_PAREN)
  if expect_res:is_err() then
    return ParseResult.err(expect_res:get_err())
  end

  local print_args: sequence(*Node)
  while not self:is({ TokenKind.CLOSE_PAREN }) do
    local parse_res: ParseResult = self:parse_expr(scope)
    if parse_res:is_err() then
      return parse_res
    end

    print_args:push(parse_res:get_ok())

    expect_res = self:advance_comma_unless(TokenKind.CLOSE_PAREN)
    if expect_res:is_err() then
      return ParseResult.err(expect_res:get_err())
    end
  end

  local expect_res = self:expect(TokenKind.CLOSE_PAREN)
  if expect_res:is_err() then
    return ParseResult.err(expect_res:get_err())
  end
  local e_token = expect_res:get_ok()

  assert(builtin_types:has("niltype"))
  return ParseResult.ok(self:new_proc_call(scope, parent.s_pos, e_token.e_pos, "print", print_args, builtin_types["niltype"]))
end

function Parser:parse_proc_call(scope: *Node, parent: *Node): ParseResult
  assert(scope and scope:is_scope())
  assert(parent and parent.type.is_proc)

  if builtin_procs:has(parent.name) then
    local proc = builtin_procs[parent.name]
    if proc == &print_proc_id_decl then
      return self:parse_print(scope, proc)
    else
      error(("Unhandled builtin proc '%s'"):format(parent.name))
    end
  end

  -- local proc_id_decl_opt = Parser.find_decl_up_scope(scope, token.val, token.s_pos.index)
  -- if proc_id_decl_opt:is_none() then
  --   return ParseResult.err(error_undefined_identifier(self, token))
  -- end

  -- local proc_id_decl = proc_id_decl_opt:get_some()
  -- if not proc_id_decl.type.is_proc then
  --   return ParseResult.err(ErrLoc.new(
  --     ErrLocKind.SYNTAX,
  --     self.loc,
  --     ("Identifier '%s' is not a function"):format(proc_id_decl.name),
  --     token.s_pos,
  --     token.e_pos)
  --   )
  -- end

  local expect_res = self:expect(TokenKind.OPEN_PAREN)
  if expect_res:is_err() then
    return ParseResult.err(expect_res:get_err())
  end

  local index = 1
  local proc_call_args: sequence(*Node)
  while not self:is({ TokenKind.CLOSE_PAREN }) do
    local parse_res = self:parse_expr(scope)
    if parse_res:is_err() then
      return parse_res
    end
    local arg = parse_res:get_ok()

    if index > #parent.type.params then
      error("Unexpected argument")
    end

    local err_loc_opt = self:check_node_type(parent.type.params[index].type, arg)
    if err_loc_opt:is_some() then
      return ParseResult.err(err_loc_opt:get_some())
    end

    proc_call_args:push(arg)

    expect_res = self:advance_comma_unless(TokenKind.CLOSE_PAREN)
    if expect_res:is_err() then
      return ParseResult.err(expect_res:get_err())
    end

    index = index + 1
  end

  expect_res = self:expect(TokenKind.CLOSE_PAREN)
  if expect_res:is_err() then
    return ParseResult.err(expect_res:get_err())
  end
  local e_token = expect_res:get_ok()

  if index - 1 ~= #parent.type.params then
    return ParseResult.err(ErrLoc.new(
      ErrLocKind.SEMANTIC,
      self.loc,
      ("proc '%s' is expecting '%d' argument(s) but got '%d'"):format(parent.name, #parent.type.params, index - 1),
      parent.s_pos,
      e_token.e_pos
    ))
  end

  return ParseResult.ok(self:new_proc_call(scope, parent.s_pos, e_token.e_pos, parent.name, proc_call_args, parent.type.ret_t))
end

function Parser:parse_array(scope: *Node): ParseResult
  assert(scope and scope:is_scope())

  local expect_res = self:expect(TokenKind.OPEN_BRACKET)
  if expect_res:is_err() then
    return ParseResult.err(expect_res:get_err())
  end
  local s_token = expect_res:get_ok()

  local array_nodes: sequence(*Node)

  while not self:is({ TokenKind.CLOSE_BRACKET }) do
    local parse_res = self:parse_expr(scope)
    if parse_res:is_err() then
      return parse_res
    end
    local array_node = parse_res:get_ok()

    if #array_nodes > 0 then
      local err_loc_opt = self:check_node_type(array_nodes[1].type, array_node)
      if err_loc_opt:is_some() then
        return ParseResult.err(ErrLoc.new(
          ErrLocKind.SEMANTIC,
          self.loc,
          "Array contains elements of different types",
          array_node.s_pos,
          array_node.e_pos
        ))
      end
    end

    array_nodes:push(array_node)

    expect_res = self:advance_comma_unless(TokenKind.CLOSE_BRACKET)
    if expect_res:is_err() then
      return ParseResult.err(expect_res:get_err())
    end
  end

  expect_res = self:expect(TokenKind.CLOSE_BRACKET)
  if expect_res:is_err() then
    return ParseResult.err(expect_res:get_err())
  end
  local e_token = expect_res:get_ok()

  local array_sub_type: *Node
  if #array_nodes > 0 then
    array_sub_type = array_nodes[1].type
  else
    assert(builtin_types:has("niltype"))
    array_sub_type = builtin_types["niltype"]
  end


  local array_type = new_array_type(scope, #array_nodes, array_sub_type, s_token.s_pos, e_token.e_pos)

  local array_node = new(Node)
  $array_node = {
    kind = NodeKind.ARRAY,
    s_pos = s_token.s_pos,
    e_pos = e_token.e_pos,
    scope = scope,

    type = array_type,
    fields = array_nodes
  }

  return ParseResult.ok(array_node)
end

function Parser:parse_index(scope: *Node, parent: *Node): ParseResult
  assert(scope and scope:is_scope())
  assert(parent and parent.type.is_array)

  local expect_res = self:expect(TokenKind.OPEN_BRACKET)
  if expect_res:is_err() then
    return ParseResult.err(expect_res:get_err())
  end

  local parse_res = self:parse_expr(scope)
  if parse_res:is_err() then
    return parse_res
  end
  local index_val = parse_res:get_ok()
  if not index_val.type.is_integral then
    error()
  end

  if index_val.kind == NodeKind.LITERAL and tointeger(index_val.lit_val) > parent.type.len then
    error()
  end

  expect_res = self:expect(TokenKind.CLOSE_BRACKET)
  if expect_res:is_err() then
    return ParseResult.err(expect_res:get_err())
  end
  local e_token = expect_res:get_ok()

  local index = new(Node)
  $index = {
    kind = NodeKind.INDEX,

    s_pos = parent.s_pos,
    e_pos = e_token.e_pos,
    scope = scope,

    type = parent.type.val,
    parent = parent,
    val = index_val,
  }

  if self:is({ TokenKind.DOT, TokenKind.OPEN_BRACKET, TokenKind.OPEN_PAREN }) then
    return self:parse_primary(scope, index)
  end

  return ParseResult.ok(index)
end

function Parser:parse_init_list(scope: *Node): ParseResult
  assert(scope and scope:is_scope())

  local expect_res = self:expect(TokenKind.OPEN_CURLY)
  if expect_res:is_err() then
    return ParseResult.err(expect_res:get_err())
  end
  local s_token = expect_res:get_ok()

  local init_list_fields: sequence(*Node)
  while not self:is({ TokenKind.CLOSE_CURLY }) do
    expect_res = self:expect(TokenKind.IDENTIFIER)
    if expect_res:is_err() then
      return ParseResult.err(expect_res:get_err())
    end
    local token = expect_res:get_ok()
    local init_field_name = token.val

    expect_res = self:expect(TokenKind.EQUALS)
    if expect_res:is_err() then
      return ParseResult.err(expect_res:get_err())
    end

    local parse_res = self:parse_expr(scope)
    if parse_res:is_err() then
      return parse_res
    end
    local init_field_val = parse_res:get_ok()

    local init_field_node: *Node = new(Node)
    $init_field_node = {
      kind = NodeKind.INIT_FIELD,

      s_pos = token.s_pos,
      e_pos = init_field_val.e_pos,

      scope = scope,

      name = init_field_name,
      val = init_field_val
    }

    init_list_fields:push(init_field_node)

    expect_res = self:advance_comma_until(TokenKind.CLOSE_CURLY)
    if expect_res:is_err() then
      return ParseResult.err(expect_res:get_err())
    end
  end

  expect_res = self:expect(TokenKind.CLOSE_CURLY)
  if expect_res:is_err() then
    return ParseResult.err(expect_res:get_err())
  end
  local e_token = expect_res:get_ok()

  local init_list_node = new(Node)
  $init_list_node = {
    kind = NodeKind.INIT_LIST,

    s_pos = s_token.s_pos,
    e_pos = e_token.e_pos,

    scope = scope,

    fields = init_list_fields
  }

  return ParseResult.ok(init_list_node)
end

function Parser:parse_field(scope: *Node, parent: *Node): ParseResult
  assert(scope and scope:is_scope())
  assert(parent and (parent.type.is_rec or parent.type.type.is_rec))

  local parent_type: *Node = parent.type.is_rec and parent.type or parent.type.type

  local expect_res = self:expect(TokenKind.DOT)
  if expect_res:is_err() then
    return ParseResult.err(expect_res:get_err())
  end
  local s_token = expect_res:get_ok()

  expect_res = self:expect(TokenKind.IDENTIFIER)
  if expect_res:is_err() then
    return ParseResult.err(expect_res:get_err())
  end
  local token = expect_res:get_ok()
  local field_name = token.val

  local found_field: *Node
  for _, field in ipairs(parent_type.fields) do
    if field.name == field_name then
      found_field = field
      break
    end
  end

  if not found_field then
    return ParseResult.err(ErrLoc.new(
      ErrLocKind.SEMANTIC,
      self.loc,
      ("Unknown field '%s' for type '%s'"):format(field_name, parent_type.name),
      token.s_pos,
      token.e_pos
    ))
  end

  local field = new(Node)
  $field = {
    kind = NodeKind.FIELD,

    s_pos = s_token.s_pos,
    e_pos = token.e_pos,

    scope = scope,

    parent = parent,
    name = field_name,
    type = found_field.type
  }

  if self:is({ TokenKind.DOT, TokenKind.OPEN_BRACKET, TokenKind.OPEN_PAREN }) then
    return self:parse_primary(scope, field)
  end

  return ParseResult.ok(field)
end

Parser.parse_primary = function(self: *Parser, scope: *Node, current_node: *Node): ParseResult
  assert(scope and scope:is_scope())

  local parse_res: ParseResult
  if not current_node then
    local token = self:peek()
    parse_res = (do
      if self:is({ TokenKind.CONSTANT_FALSE, TokenKind.CONSTANT_TRUE }) then
        in ParseResult.ok(self:new_literal(scope, builtin_types["boolean"]))
      elseif self:is({ TokenKind.INTEGER }) then
        in ParseResult.ok(self:new_literal(scope, builtin_types["i64"]))
      elseif self:is({ TokenKind.FLOAT }) then
        in ParseResult.ok(self:new_literal(scope, builtin_types["f64"]))
      elseif self:is({ TokenKind.STRING }) then
        --TODO: Not checking if this is correct since I want to keep track of string size
        in ParseResult.ok(self:new_literal(scope, builtin_types["string"]))
      elseif self:is({ TokenKind.CONSTANT_NIL }) then
        in ParseResult.ok(self:new_literal(scope, builtin_types["niltype"]))
      elseif self:is({ TokenKind.IDENTIFIER }) then
        in self:parse_id(scope)
      elseif self:is({ TokenKind.OPEN_PAREN }) then
        local parse_res = self:parse_expr(scope)
        if parse_res:get_err() then
          in parse_res
        end
        local expr = parse_res:get_ok()
        local expect_res = self:expect(TokenKind.CLOSE_PAREN)
        if expect_res:is_err() then
          in ParseResult.err(expect_res:get_err())
        end
        local e_token = expect_res:get_ok()

        error("TODO: PAREN_EXPR")
        local paren_expr = new(Node)
        $paren_expr = {}
        in ParseResult.ok(paren_expr)
      elseif self:is({ TokenKind.OPEN_BRACKET }) then
        in self:parse_array(scope)
      elseif self:is({ TokenKind.OPEN_CURLY }) then
        in self:parse_init_list(scope)
      elseif self:is({ TokenKind.KEYWORD_RECORD }) then
        in self:parse_record(scope)
      else
        in ParseResult.err(error_unexpected_token(self, token))
      end
    end)

    if parse_res:is_err() then
      return parse_res
    end

    current_node = parse_res:get_ok()
  end

  if current_node and current_node.type then
    local typ: *Node = current_node.type
    if (typ.type.is_rec or typ.is_rec) and self:is({ TokenKind.DOT }) then
      return self:parse_field(scope, current_node)
    elseif typ.is_proc and self:is({ TokenKind.OPEN_PAREN }) then
      return self:parse_proc_call(scope, current_node)
    elseif typ.is_array and self:is({ TokenKind.OPEN_BRACKET }) then
      return self:parse_index(scope, current_node)
    else
      parse_res = ParseResult.ok(current_node)
    end
  end

  return parse_res
end

function Parser:parse_unary(scope: *Node): ParseResult
  assert(scope and scope:is_scope())

  if self:is({TokenKind.MINUS, TokenKind.PLUS}) then
    local op_token = self:advance()

    error("UNARY")
    local unary = new(Node)
    $unary = {}
    return ParseResult.ok(unary)
  end

  return self:parse_primary(scope)
end

function Parser:parse_factor(scope: *Node): ParseResult
  assert(scope and scope:is_scope())

  local parse_res = self:parse_unary(scope)
  if parse_res:is_err() then
    return parse_res
  end

  local lhs = parse_res:get_ok()

  while self:is({ TokenKind.STAR }) do
    local op_token = self:advance()

    local parse_res = self:parse_unary(scope)
    if parse_res:is_err() then
      return parse_res
    end
    local rhs = parse_res:get_ok()

    parse_res = ParseResult.ok(self:new_binary_expr(scope, lhs, op_token, rhs))
    if parse_res:is_err() then
      return parse_res
    end
    lhs = parse_res:get_ok()
  end

  return ParseResult.ok(lhs)
end

function Parser:parse_term(scope: *Node): ParseResult
  assert(scope and scope:is_scope())

  local parse_res = self:parse_factor(scope)
  if parse_res:is_err() then
    return parse_res
  end

  local lhs = parse_res:get_ok()

  while self:is({ TokenKind.MINUS, TokenKind.PLUS }) do
    local op_token = self:advance()

    local parse_res = self:parse_factor(scope)
    if parse_res:is_err() then
      return parse_res
    end
    local rhs = parse_res:get_ok()

    parse_res = ParseResult.ok(self:new_binary_expr(scope, lhs, op_token, rhs))
    if parse_res:is_err() then
      return parse_res
    end
    lhs = parse_res:get_ok()
  end

  return ParseResult.ok(lhs)
end

function Parser:parse_comparison(scope: *Node): ParseResult
  assert(scope and scope:is_scope())

  local parse_res = self:parse_term(scope)
  if parse_res:is_err() then
    return parse_res
  end

  local lhs = parse_res:get_ok()

  while self:is({ TokenKind.OPEN_ANGLE, TokenKind.CLOSE_ANGLE, TokenKind.LT_EQS, TokenKind.GT_EQS }) do
    local op_token = self:advance()

    local parse_res = self:parse_term(scope)
    if parse_res:is_err() then
      return parse_res
    end
    local rhs = parse_res:get_ok()

    parse_res = ParseResult.ok(self:new_binary_expr(scope, lhs, op_token, rhs))
    if parse_res:is_err() then
      return parse_res
    end
    lhs = parse_res:get_ok()
  end

  return ParseResult.ok(lhs)
end

function Parser:parse_equality(scope: *Node): ParseResult
  assert(scope and scope:is_scope())

  local parse_res = self:parse_comparison(scope)
  if parse_res:is_err() then
    return parse_res
  end

  local lhs = parse_res:get_ok()

  while self:is({ TokenKind.NOT_EQS, TokenKind.EQUATES }) do
    local op_token = self:advance()

    local parse_res = self:parse_comparison(scope)
    if parse_res:is_err() then
      return parse_res
    end
    local rhs = parse_res:get_ok()

    parse_res = ParseResult.ok(self:new_binary_expr(scope, lhs, op_token, rhs))
    if parse_res:is_err() then
      return parse_res
    end
    lhs = parse_res:get_ok()
  end

  return ParseResult.ok(lhs)
end

Parser.parse_expr = function(self: *Parser, scope: *Node): ParseResult
  assert(scope and scope:is_scope())
  return self:parse_equality(scope)
end

function Parser:parse_type(scope: *Node): ParseResult
  assert(scope and scope:is_scope())

  if self:is({ TokenKind.OPEN_BRACKET }) then
    local s_token = self:advance()

    -- TODO: Should also work with comptime values
    local expect_res = self:expect(TokenKind.INTEGER)
    if expect_res:is_err() then
      return ParseResult.err(expect_res:get_err())
    end
    local array_len = tointeger(expect_res:get_ok().val)

    local expect_res = self:expect(TokenKind.CLOSE_BRACKET)
    if expect_res:is_err() then
      return ParseResult.err(expect_res:get_err())
    end

    local parse_res = self:parse_type(scope)
    if parse_res:is_err() then
      return parse_res
    end
    local array_sub_type = parse_res:get_ok()

    local array_type_name_sb: stringbuilder
    array_type_name_sb:write("[", array_len, "]", array_sub_type.name)

    local e_token = self:peek_prev()

    local array_type = new(Node)

    return ParseResult.ok(new_array_type(scope, array_len, array_sub_type, s_token.s_pos, e_token.e_pos))
  end

  if self:is({ TokenKind.KEYWORD_RECORD }) then
    return self:parse_record(scope)
  end

  local token = self:peek()
  if not self:is({ TokenKind.IDENTIFIER }) then
    return ParseResult.err(error_unexpected_token(self, token))
  end

  if self:is({ TokenKind.IDENTIFIER }) then
    if builtin_types:has(token.val) then
      self:advance()
      return ParseResult.ok(builtin_types[token.val])
    else
      local parse_res = self:parse_id(scope)
      if parse_res:is_err() then
        return parse_res
      end
      local id = parse_res:get_ok()

      if not id.type.is_type then
        print(id:tostring())
        error()
      end

      return ParseResult.ok(id)
    end
  end

  return ParseResult.err(error_unexpected_token(self, token))
end

local AnnotationsResult = @Result(Annotations, ErrLoc)

function Parser:parse_annotations(): AnnotationsResult
  local annotations: Annotations

  local expect_res = self:expect(TokenKind.OPEN_ANGLE)
  if expect_res:is_err() then
    return AnnotationsResult.err(expect_res:get_err())
  end

  while not self:is({ TokenKind.CLOSE_ANGLE }) do
    local token = self:advance()

    if token.val == "const" then
      annotations.constant = true
    else
      error(("Unexpected annotation '%s'"):format(token.val))
    end

    expect_res = self:advance_comma_unless(TokenKind.CLOSE_ANGLE)
    if expect_res:is_err() then
      return AnnotationsResult.err(expect_res:get_err())
    end
  end

  expect_res = self:expect(TokenKind.CLOSE_ANGLE)
  if expect_res:is_err() then
    return AnnotationsResult.err(expect_res:get_err())
  end

  return AnnotationsResult.ok(annotations)
end

function Parser:parse_id_decl(scope: *Node, in_rec: boolean): ParseResult
  assert(scope and scope:is_scope())

  local expect_res = self:expect(TokenKind.IDENTIFIER)
  if expect_res:is_err() then
    return ParseResult.err(expect_res:get_err())
  end
  local s_token = expect_res:get_ok()
  local token = s_token
  local id_name = token.val

  if not in_rec then
    local decl_opt = Parser.find_decl_up_scope(scope, id_name, token.s_pos.index)
    if decl_opt:is_some() then
      return ParseResult.err(error_redeclaration(self, token))
    end
  end

  expect_res = self:expect(TokenKind.COLON)
  if expect_res:is_err() then
    return ParseResult.err(expect_res:get_err())
  end

  local id_type: *Node
  if self:is({ TokenKind.IDENTIFIER, TokenKind.OPEN_BRACKET, TokenKind.KEYWORD_RECORD }) then
    local parse_res = self:parse_type(scope)
    if parse_res:is_err() then
      return parse_res
    end

    id_type = parse_res:get_ok()
  end

  local id_decl_annotations: Annotations
  if self:is({ TokenKind.OPEN_ANGLE }) then
    local annot_res = self:parse_annotations()
    if annot_res:is_err() then
      return ParseResult.err(annot_res:get_err())
    end

    id_decl_annotations = annot_res:get_ok()
  end

  local id_val: *Node
  if self:is({ TokenKind.EQUALS }) then
    expect_res = self:expect(TokenKind.EQUALS)
    if expect_res:is_err() then
      return ParseResult.err(expect_res:get_err())
    end
    local parse_res = self:parse_expr(scope)
    if parse_res:is_err() then
      return parse_res
    end

    id_val = parse_res:get_ok()
    if id_type then
      local err_loc_opt = self:check_node_type(id_type, id_val)
      if err_loc_opt:is_some() then
        return ParseResult.err(err_loc_opt:get_some())
      end
    else
      id_type = id_val.is_type and id_val or id_val.type
    end
  end

  local prev_token = self:peek_prev()

  if not id_type and not id_val then
    return ParseResult.err(ErrLoc.new(
      ErrLocKind.SYNTAX,
      self.loc,
      "Expected either a 'type' or '=' after ':'",
      prev_token.s_pos,
      prev_token.e_pos
    ))
  end

  if id_val and (id_val.is_type or id_val.is_type_id) and not id_decl_annotations.constant then
    return ParseResult.err(ErrLoc.new(
      ErrLocKind.SEMANTIC,
      self.loc,
      "Type declaration must be a constant",
      s_token.s_pos,
      s_token.e_pos
    ))
  end

  local id_decl = new(Node)
  $id_decl = {
    kind = NodeKind.ID_DECL,

    s_pos = s_token.s_pos,
    e_pos = prev_token.e_pos,
    scope = scope,

    type = id_type,
    name = id_name,
    annotations = id_decl_annotations,
    val = id_val
  }
  return ParseResult.ok(id_decl)
end

function Parser:parse_assignment(scope: *Node): ParseResult
  assert(scope and scope:is_scope())

  local parse_res = self:parse_id(scope)
  if parse_res:is_err() then
    return parse_res
  end
  local assignment_id = parse_res:get_ok()

  if assignment_id.annotations.constant then
    return ParseResult.err(ErrLoc.new(
      ErrLocKind.SEMANTIC,
      self.loc,
      "constant values cannot be reassigned",
      assignment_id.s_pos,
      assignment_id.e_pos
    ))
  end

  local expect_res = self:expect(TokenKind.EQUALS)
  if expect_res:is_err() then
    return ParseResult.err(expect_res:get_err())
  end

  parse_res = self:parse_expr(scope)
  if parse_res:is_err() then
    return parse_res
  end
  local assignment_val = parse_res:get_ok()

  local err_loc_opt = self:check_node_type(assignment_id.type, assignment_val)
  if err_loc_opt:is_some() then
    return ParseResult.err(err_loc_opt:get_some())
  end

  local assignment_node: *Node = new(Node)
  $assignment_node = {
    kind = NodeKind.ASSIGNMENT,

    s_pos = assignment_id.s_pos,
    e_pos = assignment_val.e_pos,
    scope = scope,

    id = assignment_id,
    val = assignment_val
  }

  return ParseResult.ok(assignment_node)
end

local function get_returns(scope: *Node, rets: *sequence(*Node))
  assert(scope and scope:is_scope())
  for _, child in ipairs(scope.children) do
    if child.kind == NodeKind.RETURN then
      rets:push(child)
    end

    if child:is_scope() then
      get_returns(child, rets)
    end
  end
end

function Parser:parse_proc_def(scope: *Node): ParseResult
  assert(scope and scope:is_scope())

  local expect_res = self:expect(TokenKind.KEYWORD_PROC)
  if expect_res:is_err() then
    return ParseResult.err(expect_res:get_err())
  end
  local s_token = expect_res:get_ok()
  local token = s_token

  local expect_res = self:expect(TokenKind.IDENTIFIER)
  if expect_res:is_err() then
    return ParseResult.err(expect_res:get_err())
  end
  local proc_def_name = expect_res:get_ok().val

  local decl_opt = Parser.find_decl_up_scope(scope, proc_def_name, token.s_pos.index)
  if decl_opt:is_some() then
    return ParseResult.err(error_redeclaration(self, token))
  end

  local proc_def = new(Node)

  $proc_def = {
    kind = NodeKind.PROC_DEF,
    s_pos = s_token.s_pos,
    scope = scope,

    name = proc_def_name,
    annotations = { constant = true },
  }

  expect_res = self:expect(TokenKind.OPEN_PAREN)
  if expect_res:is_err() then
    return ParseResult.err(expect_res:get_err())
  end

  while not self:is({ TokenKind.CLOSE_PAREN }) do
    local parse_res: ParseResult = self:parse_id_decl(scope)
    if parse_res:is_err() then
      return parse_res
    end

    local param = parse_res:get_ok()
    proc_def.params:push(param)
    -- NOTE: Hack to make params available in scope
    proc_def.children:push(param)

    expect_res = self:advance_comma_unless(TokenKind.CLOSE_PAREN)
    if expect_res:is_err() then
      return ParseResult.err(expect_res:get_err())
    end
  end

  expect_res = self:expect(TokenKind.CLOSE_PAREN)
  if expect_res:is_err() then
    return ParseResult.err(expect_res:get_err())
  end

  if self:is({ TokenKind.COLON }) then
    expect_res = self:expect(TokenKind.COLON)
    if expect_res:is_err() then
      return ParseResult.err(expect_res:get_err())
    end

    local parse_res = self:parse_type(scope)
    if parse_res:is_err() then
      return parse_res
    end
    proc_def.ret_t = parse_res:get_ok()
  end

  local proc_sig_end = self:peek_prev()

  if not proc_def.ret_t then
    assert(builtin_types:has("niltype"))
    proc_def.ret_t = builtin_types["niltype"]
  end

  local proc_type = new(Node)
  $proc_type = {
    kind = NodeKind.TYPE,
    name = "proc_def",
    is_proc = true,
    is_type = true,
    params = proc_def.params,
    ret_t = proc_def.ret_t,
    type = &type_type
  }
  proc_def.type = proc_type

  -- NOTE: Hack to make proc available in scope
  local proc_id_decl = new(Node)
  $proc_id_decl = {
    kind = NodeKind.ID_DECL,

    s_pos = proc_def.s_pos,
    e_pos = proc_sig_end.e_pos,
    scope = scope,

    name = proc_def.name,
    val = proc_def,
    annotations = { constant = true },
    type = proc_def.type,
  }
  proc_def.children:push(proc_id_decl)

  expect_res = self:expect(TokenKind.OPEN_CURLY)
  if expect_res:is_err() then
    return ParseResult.err(expect_res:get_err())
  end

  while not self:is({ TokenKind.CLOSE_CURLY }) do
    local parse_res = self:parse_scope(proc_def, TokenKind.CLOSE_CURLY)
    if parse_res:is_err() then
      return parse_res
    else
      break
    end
  end

  local rets: sequence(*Node)
  get_returns(proc_def, &rets)
  for _, ret in ipairs(rets) do
    local ret_stmt_val = ret.val
    if self:check_node_type(proc_def.ret_t, ret_stmt_val):is_some() then
      return ParseResult.err({
        kind = ErrLocKind.SEMANTIC,

        loc = self.loc,
        err = ("Return statement type '%s' does not match defined return type '%s'"):format(ret_stmt_val.type.name, proc_def.ret_t.name),

        s_pos = ret_stmt_val.s_pos,
        e_pos = ret_stmt_val.e_pos,
      })
    end
  end

  expect_res = self:expect(TokenKind.CLOSE_CURLY)
  if expect_res:is_err() then
    return ParseResult.err(expect_res:get_err())
  end
  token = expect_res:get_ok()

  for _, param in ipairs(proc_def.params) do
    for i, child in ipairs(proc_def.children) do
      if param == child then
        proc_def.children:remove(i)
        break
      end
    end
  end
  proc_def.children:remove(1)

  proc_def.e_pos = token.e_pos
  proc_def.content = self.loc.content:sub(proc_def.s_pos.index, proc_def.e_pos.index)

  return ParseResult.ok(proc_def)
end

function Parser:parse_return_node(scope: *Node): ParseResult

  local expect_res = self:expect(TokenKind.KEYWORD_RETURN)
  if expect_res:is_err() then
    return ParseResult.err(expect_res:get_err())
  end
  local s_token = expect_res:get_ok()
  local token = s_token

  local node: *Node = new(Node)
  local _node: Node = $node
  _node = {
    s_pos = token.s_pos,
    kind = NodeKind.RETURN,
    scope = scope,
  }

  local ret_value: *Node
  if self:peek().kind ~= TokenKind.CLOSE_CURLY then
    local parse_res = self:parse_expr(scope)
    if parse_res:is_err() then
      return parse_res
    end
    ret_value = parse_res:get_ok()
  end
  local token = self:peek_prev()

  _node.e_pos = token.e_pos
  _node.val = ret_value
  $node = _node
  return ParseResult.ok(node)
end

function Parser:parse_while_loop(scope: *Node): ParseResult
  assert(scope and scope:is_scope())

  local expect_res = self:expect(TokenKind.KEYWORD_WHILE)
  if expect_res:is_err() then
    return ParseResult.err(expect_res:get_err())
  end
  local s_token = expect_res:get_ok()

  local parse_res = self:parse_expr(scope)
  if parse_res:is_err() then
    return parse_res
  end
  local while_cond = parse_res:get_ok()

  expect_res = self:expect(TokenKind.OPEN_CURLY)
  if expect_res:is_err() then
    return ParseResult.err(expect_res:get_err())
  end

  local while_loop = new(Node)

  $while_loop = {
    kind = NodeKind.WHILE_LOOP,
    s_pos = s_token.s_pos,
    scope = scope,

    cond = while_cond
  }

  while not self:is({ TokenKind.CLOSE_CURLY }) do
    parse_res = self:parse_scope(while_loop, TokenKind.CLOSE_CURLY)
    if parse_res:is_err() then
      return parse_res
    else
      break
    end
  end

  expect_res = self:expect(TokenKind.CLOSE_CURLY)
  if expect_res:is_err() then
    return ParseResult.err(expect_res:get_err())
  end
  local e_token = expect_res:get_ok()

  while_loop.e_pos = e_token.e_pos
  while_loop.content = self.loc.content:sub(while_loop.s_pos.index, while_loop.e_pos.index)

  return ParseResult.ok(while_loop)
end

function Parser:parse_for_loop(scope: *Node): ParseResult
  assert(scope and scope:is_scope())

  local expect_res = self:expect(TokenKind.KEYWORD_FOR)
  if expect_res:is_err() then
    return ParseResult.err(expect_res:get_err())
  end
  local s_token = expect_res:get_ok()

  local parse_res = self:parse_id_decl(scope)
  if parse_res:is_err() then
    return parse_res
  end

  local for_loop_id = parse_res:get_ok()
  if not for_loop_id.type.is_integral then
    error()
  end

  local expect_res = self:expect(TokenKind.COMMA)
  if expect_res:is_err() then
    return ParseResult.err(expect_res:get_err())
  end

  parse_res = self:parse_expr(scope)
  if parse_res:is_err() then
    return parse_res
  end

  local for_loop_cond = parse_res:get_ok()
  if not for_loop_cond.type.is_integral then
    error()
  end

  local for_loop_step: *Node
  if self:is({ TokenKind.COMMA }) then
    self:advance()
    parse_res = self:parse_expr(scope)
    if parse_res:is_err() then
      return parse_res
    end
    for_loop_step = parse_res:get_ok()
    if not for_loop_step.type.is_integral then
      error()
    end
  end

  expect_res = self:expect(TokenKind.OPEN_CURLY)
  if expect_res:is_err() then
    return ParseResult.err(expect_res:get_err())
  end

  local for_loop = new(Node)

  $for_loop = {
    kind = NodeKind.FOR_LOOP,
    s_pos = s_token.s_pos,
    scope = scope,

    id = for_loop_id,
    cond = for_loop_cond,
    step = for_loop_step
  }

  for_loop.children:push(for_loop_id)

  while not self:is({ TokenKind.CLOSE_CURLY }) do
    parse_res = self:parse_scope(for_loop, TokenKind.CLOSE_CURLY)
    if parse_res:is_err() then
      return parse_res
    else
      break
    end
  end

  -- First children is always the loop id
  for_loop.children:remove(1)

  expect_res = self:expect(TokenKind.CLOSE_CURLY)
  if expect_res:is_err() then
    return ParseResult.err(expect_res:get_err())
  end
  local e_token = expect_res:get_ok()

  for_loop.e_pos = e_token.e_pos
  for_loop.content = self.loc.content:sub(for_loop.s_pos.index, for_loop.e_pos.index)

  return ParseResult.ok(for_loop)
end

function Parser:parse_if_stmt(scope: *Node): ParseResult
  assert(scope and scope:is_scope())

  local expect_res = self:expect(TokenKind.KEYWORD_IF)
  if expect_res:is_err() then
    return ParseResult.err(expect_res:get_err())
  end
  local s_token = expect_res:get_ok()

  local parse_res = self:parse_expr(scope)
  if parse_res:is_err() then
    return parse_res
  end
  local if_cond = parse_res:get_ok()

  expect_res = self:expect(TokenKind.OPEN_CURLY)
  if expect_res:is_err() then
    return ParseResult.err(expect_res:get_err())
  end

  local if_stmt = new(Node)

  $if_stmt = {
    kind = NodeKind.IF_STMT,
    s_pos = s_token.s_pos,
    scope = scope,

    cond = if_cond
  }

  while not self:is({ TokenKind.CLOSE_CURLY }) do
    parse_res = self:parse_scope(if_stmt, TokenKind.CLOSE_CURLY)
    if parse_res:is_err() then
      return parse_res
    else
      break
    end
  end

  expect_res = self:expect(TokenKind.CLOSE_CURLY)
  if expect_res:is_err() then
    return ParseResult.err(expect_res:get_err())
  end
  local e_token = expect_res:get_ok()

  if_stmt.e_pos = e_token.e_pos
  if_stmt.content = self.loc.content:sub(if_stmt.s_pos.index, if_stmt.e_pos.index)

  return ParseResult.ok(if_stmt)
end

function Parser:parse_elif_stmt(scope: *Node): ParseResult
  assert(scope and scope:is_scope())

  local expect_res = self:expect(TokenKind.KEYWORD_ELIF)
  if expect_res:is_err() then
    return ParseResult.err(expect_res:get_err())
  end
  local s_token = expect_res:get_ok()

  if scope.children[#scope.children].kind ~= NodeKind.IF_STMT then
    return ParseResult.err(ErrLoc.new(ErrLocKind.SYNTAX, self.loc, "if statement expected before elif", s_token.s_pos, s_token.e_pos))
  end

  local parse_res = self:parse_expr(scope)
  if parse_res:is_err() then
    return parse_res
  end
  local elif_cond = parse_res:get_ok()

  expect_res = self:expect(TokenKind.OPEN_CURLY)
  if expect_res:is_err() then
    return ParseResult.err(expect_res:get_err())
  end

  local elif_stmt = new(Node)

  $elif_stmt = {
    kind = NodeKind.ELIF_STMT,
    s_pos = s_token.s_pos,
    scope = scope,

    cond = elif_cond
  }

  while not self:is({ TokenKind.CLOSE_CURLY }) do
    parse_res = self:parse_scope(elif_stmt, TokenKind.CLOSE_CURLY)
    if parse_res:is_err() then
      return parse_res
    else
      break
    end
  end

  expect_res = self:expect(TokenKind.CLOSE_CURLY)
  if expect_res:is_err() then
    return ParseResult.err(expect_res:get_err())
  end
  local e_token = expect_res:get_ok()

  elif_stmt.e_pos = e_token.e_pos
  elif_stmt.content = self.loc.content:sub(elif_stmt.s_pos.index, elif_stmt.e_pos.index)

  return ParseResult.ok(elif_stmt)
end

function Parser:parse_else_stmt(scope: *Node): ParseResult
  assert(scope and scope:is_scope())

  local expect_res = self:expect(TokenKind.KEYWORD_ELSE)
  if expect_res:is_err() then
    return ParseResult.err(expect_res:get_err())
  end
  local s_token = expect_res:get_ok()

  if scope.children[#scope.children].kind ~= NodeKind.IF_STMT and scope.children[#scope.children].kind ~= NodeKind.ELIF_STMT then
    return ParseResult.err(ErrLoc.new(ErrLocKind.SYNTAX, self.loc, "either if or elif statement expected before else", s_token.s_pos, s_token.e_pos))
  end

  expect_res = self:expect(TokenKind.OPEN_CURLY)
  if expect_res:is_err() then
    return ParseResult.err(expect_res:get_err())
  end

  local else_stmt = new(Node)

  $else_stmt = {
    kind = NodeKind.ELSE_STMT,
    s_pos = s_token.s_pos,
    scope = scope,
  }

  while not self:is({ TokenKind.CLOSE_CURLY }) do
    local parse_res = self:parse_scope(else_stmt, TokenKind.CLOSE_CURLY)
    if parse_res:is_err() then
      return parse_res
    else
      break
    end
  end

  expect_res = self:expect(TokenKind.CLOSE_CURLY)
  if expect_res:is_err() then
    return ParseResult.err(expect_res:get_err())
  end
  local e_token = expect_res:get_ok()

  else_stmt.e_pos = e_token.e_pos
  else_stmt.content = self.loc.content:sub(else_stmt.s_pos.index, else_stmt.e_pos.index)

  return ParseResult.ok(else_stmt)
end

Parser.parse_record = function(self: *Parser, scope: *Node): ParseResult
  local expect_res = self:expect(TokenKind.KEYWORD_RECORD)
  if expect_res:is_err() then
    return ParseResult.err(expect_res:get_err())
  end
  local s_token = expect_res:get_ok()

  local record_is_anonymous: boolean
  local record_name: string
  if self:is({ TokenKind.IDENTIFIER }) then
    local token = self:advance()
    record_name = token.val

    local decl_opt = Parser.find_decl_up_scope(scope, record_name, token.s_pos.index)
    if decl_opt:is_some() then
      return ParseResult.err(error_redeclaration(self, token))
    end
  else
    record_is_anonymous = true
    record_name = "anon_record"
  end

  expect_res = self:expect(TokenKind.OPEN_CURLY)
  if expect_res:is_err() then
    return ParseResult.err(expect_res:get_err())
  end

  local record_fields: sequence(*Node)
  while not self:is({ TokenKind.CLOSE_CURLY }) do
    local parse_res = self:parse_id_decl(scope, true)
    if parse_res:is_err() then
      return parse_res
    end

    record_fields:push(parse_res:get_ok())

    expect_res = self:advance_comma_until(TokenKind.CLOSE_CURLY)
    if expect_res:is_err() then
      return ParseResult.err(expect_res:get_err())
    end
  end

  expect_res = self:expect(TokenKind.CLOSE_CURLY)
  if expect_res:is_err() then
    return ParseResult.err(expect_res:get_err())
  end
  local e_token = expect_res:get_ok()

  local record_node = new(Node)
  $record_node = {
    kind = NodeKind.TYPE,

    s_pos = s_token.s_pos,
    e_pos = e_token.e_pos,
    scope = scope,

    name = record_name,
    fields = record_fields,
    is_rec = true,
    is_type = true,
    is_anonymous = record_is_anonymous,
    annotations = { constant = true },
    type = &type_type
  }
  return ParseResult.ok(record_node)
end

Parser.parse_scope = function(self: *Parser, scope: *Node, till: TokenKind): ParseResult
  assert(scope and scope:is_scope())
  range_check!(till, TokenKind)

  local token = self:peek()
  if token.kind == till then
    return ParseResult.ok(scope)
  end

  local parse_res: ParseResult = _switch!(token.kind, {
    [TokenKind.COMMENT] = (do
      self:advance()
      local node: *Node = new(Node)
      $node = {
        s_pos = token.s_pos,
        e_pos = token.e_pos,
        kind = NodeKind.COMMENT,
        scope = scope,
      }
      in ParseResult.ok(node)
    end),
    [TokenKind.IDENTIFIER] = (do
      if self:peek_next().kind == TokenKind.COLON then
        in self:parse_id_decl(scope)
      elseif self:peek_next().kind == TokenKind.OPEN_PAREN then
        in self:parse_primary(scope)
      elseif self:peek_next().kind == TokenKind.EQUALS then
        in self:parse_assignment(scope)
      end
      in self:parse_id(scope)
    end),
    [TokenKind.KEYWORD_PROC] = self:parse_proc_def(scope),
    [TokenKind.KEYWORD_RETURN] = self:parse_return_node(scope),
    [TokenKind.KEYWORD_IF] = self:parse_if_stmt(scope),
    [TokenKind.KEYWORD_ELIF] = self:parse_elif_stmt(scope),
    [TokenKind.KEYWORD_ELSE] = self:parse_else_stmt(scope),
    [TokenKind.KEYWORD_WHILE] = self:parse_while_loop(scope),
    [TokenKind.KEYWORD_RECORD] = self:parse_record(scope),
    [TokenKind.KEYWORD_FOR] = self:parse_for_loop(scope),
    [TokenKind.KEYWORD_BREAK] = (do
      self:advance()
      if not scope:is_loop() then
        return ParseResult.err(ErrLoc.new(ErrLocKind.SEMANTIC, self.loc, "break statements must be within a loop", token.s_pos, token.e_pos))
      end
      local node: *Node = new(Node)
      $node = {
        kind = NodeKind.BREAK,

        s_pos = token.s_pos,
        e_pos = token.e_pos,

        scope = scope,
      }
      in ParseResult.ok(node)
    end),
    _default = (do
      error(("Unexpected Tokenkind '%s'"):format(TokenKind_tostring(token.kind)))
      in ParseResult.err({})
    end)
  })

  if parse_res:is_err() then
    return parse_res
  end

  local child = parse_res:get_ok()
  scope.children:push(child)

  return self:parse_scope(scope, till)
end

function Parser:parse(): ParseResult
  local ast = new(Node)
  local s_line, s_col = pos_to_line_col(1, self.loc.content)
  local e_line, e_col = pos_to_line_col(#self.loc.content, self.loc.content)
  $ast = {
    kind = NodeKind.AST,

    s_pos = {
      index = 1,
      line = s_line,
      col = s_col
    },
    e_pos = {
      index = #self.loc.content,
      line = e_line,
      col = e_col
    },
    scope = nilptr,

    content = self.loc.content,
  }
  local res = self:parse_scope(ast, TokenKind.EOF)
  if res:is_err() then
    return ParseResult.err(res:get_err())
  end
  return ParseResult.ok(res:get_ok())
end

local Parser.NodeKind = NodeKind
local Parser.NodeKind_tostring = NodeKind_tostring
local Parser.Node = Node
local Parser.builtin_types = builtin_types
return Parser
